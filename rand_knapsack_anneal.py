#################################### QUESTION 3: SIMULATED ANNEALING ##################################### need some python librariesimport copyfrom random import Randomimport numpy as npimport math# to setup a random number generator, we will specify a "seed" valueseed = 12345myPRNG = Random(seed)# to get a random number between 0 and 1, write call this:             myPRNG.random()# to get a random number between lwrBnd and upprBnd, write call this:  myPRNG.uniform(lwrBnd,upprBnd)# to get a random integer between lwrBnd and upprBnd, write call this: myPRNG.randint(lwrBnd,upprBnd)# number of elements in a solutionn = 100# let's create an instance for the knapsack problemvalues = []for i in xrange(0,n):    values.append(myPRNG.randint(10,100))weights = []for i in xrange(0,n):    weights.append(myPRNG.randint(5,15))# Define max weight for the knapsackmaxWeight = 4*n# Function to evaluate a solution xdef evaluate(x):    a=np.array(x)    b=np.array(values)    c=np.array(weights)    value = np.dot(a,b)          #compute the cost value of the knapsack selection    totalWeight = np.dot(a,c)    #compute the weight value of the knapsack selection    if totalWeight > maxWeight:        value = -1    return value# Function to create a 1-flip neighborhood of solution xdef neighborhood(x):    nbrhood = []    for i in xrange(0,n):        nbrhood.append(x[:])        if nbrhood[i][i] == 1:            nbrhood[i][i] = 0        else:            nbrhood[i][i] = 1    return nbrhood# Function to select a solution at randomdef getRandomPoint(prng):    xRand = []    for i in xrange(0,n):        if prng.random() < 0.7:            xRand.append(0)        else:            xRand.append(1)    return xRand############################################## HELPER FUNCTIONS FOR SIMULATED ANNEALING  ############################################### Function to update the new temperatured#   input: current temperature#   output: new temperature (real)def getNextTemp(t):    alpha = 0.98    t_new = t * alpha    return t_new# Function to return the probability that a worse solution will be accepted as the new position.def get_pAccept(xCurr, xNew, temp):    import math    vCurr = evaluate(xCurr)    vNew = evaluate(xNew)    return math.exp((vNew - vCurr)/temp)# Prints a status update to the consoledef printUpdate():    print "\nTotal number of solutions checked: ", solutionsChecked    print "Temperature: ", T    print "Value of current position: ", f_curr    print "Current position: ", x_curr################################## SIMULATED ANNEALING PROCEDURE ##################################T = 20                # starting temperatureiter_per_temp = 1000  # number of iterations per temperature.t_min = 1             # minimum temperature at which to end the searchsolutionsChecked = 0  # number of solutions checked.### Initialize the current position ###x_curr = getRandomPoint(myPRNG)   # select a random solution in the space.f_curr = evaluate(x_curr)         # evaluate the current point.# Perform simulated annealing from the starting pointwhile T > t_min:    # while stopping condition not met    for i in xrange(1,iter_per_temp):        Neighborhood = neighborhood(x_curr)  # create a list of all neighbors in the neighborhood of x_curr        s = Neighborhood[myPRNG.randint(1,len(Neighborhood)-1)]  # select a random neighbor.        f_s = evaluate(s)   # evaluate the neighbor        solutionsChecked += 1        if f_s > f_curr:    #if the neighbor evaluates better than the current position:            x_curr = s      #move to that point            f_curr = f_s    #update the evaluation score of the current position        elif myPRNG.random() < get_pAccept(x_curr, s, T):            x_curr = s      # move to that point            f_curr = f_s    # update the evaluation score of the current position    T = getNextTemp(T)    printUpdate()printUpdate()