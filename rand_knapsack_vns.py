#################################### 6) VARIABLE NEIGHBORHOOD SEARCH ##################################### need some python librariesimport copyfrom random import Randomimport numpy as npimport math# to setup a random number generator, we will specify a "seed" valueseed = 12345myPRNG = Random(seed)# to get a random number between 0 and 1, write call this:             myPRNG.random()# to get a random number between lwrBnd and upprBnd, write call this:  myPRNG.uniform(lwrBnd,upprBnd)# to get a random integer between lwrBnd and upprBnd, write call this: myPRNG.randint(lwrBnd,upprBnd)# number of elements in a solutionn = 100# let's create an instance for the knapsack problemvalues = []for i in xrange(0,n):    values.append(myPRNG.randint(10,100))weights = []for i in xrange(0,n):    weights.append(myPRNG.randint(5,15))# define max weight for the knapsackmaxWeight = 4*n# function to evaluate a solution xdef evaluate(x):    a=np.array(x)    b=np.array(values)    c=np.array(weights)    value = np.dot(a,b)          #compute the cost value of the knapsack selection    totalWeight = np.dot(a,c)    #compute the weight value of the knapsack selection    if totalWeight > maxWeight:        value = -1    return value# function to select a solution at randomdef getRandomPoint(prng):    xRand = []    for i in xrange(0,n):        if prng.random() < 0.7:            xRand.append(0)        else:            xRand.append(1)    return xRanddef printUpdate():    print "\nTotal number of solutions checked: ", solutionsChecked    print "Total starts: ", starts    print "Through neighborhood k = ", k    print "Best fitness found: ", f_best    print "Best solution found: ", x_best    print "Best overall solution: ", x_best_overall    print "Best overall fitness: ", f_best_overall########################################################### HELPER FUNCTIONS FOR TABU VARIABLE NEIGHBORHOOD SEARCH ############################################################ function to return a list of the k-th neighborhood structure around a given solution x#   for k = 1: 1-flip neighborhood w.r.t. x#   for k = 2: 2-flip neighborhood w.r.t. x#   for k = 3: 1-flip + 1-swap neighborhood w.r.t. xdef neighborhood(x, k):    nbrhood = []  # start with an empty list    for i in xrange(0,len(x)):        nbrhood.append(x[:])        if nbrhood[i][i] == 1:            nbrhood[i][i] = 0        else:            nbrhood[i][i] = 1    one_flip = nbrhood[:]    #  2nd neighborhood structure: add another flip.    if k <= 2:        for i in xrange(0, len(one_flip)):            for j in xrange(0, len(x)):                x_new = one_flip[i][:]                if x_new[j] == 0:                    x_new[j] = 1                else:                    x_new[j] = 0                nbrhood.append(x_new)    # 3rd neighborhood structure: add a random swap    elif k > 2:        for i in xrange(0, len(one_flip)):            for j in xrange(0, len(x)):                x_new = one_flip[i][:]                # swap item j with another randomly selected item (can't swap with itself)                swap_buddy = j                while swap_buddy == j:                    swap_buddy = myPRNG.randint(0,len(x)-1)                a = x_new[j]                x_new[j] = x_new[swap_buddy]                x_new[swap_buddy] = a                nbrhood.append(x_new)    return nbrhood######################################################################## VARIABLE NEIGHBORHOOD SEARCH (variable neighborhood descent method) ######################################################################### Details:#   Variable neighborhood descent with 2 random starts#   Neighborhood structure #1: all 1-flip neighbors#   Neighborhood structure #2: all 2-flip neighbors (1-flip neighbors OF 1-flip neighbors)#   Neighborhood structure #3: all Instead of the 2nd flip, add a random swap:#       For each element i in solution x, swap x[i] with a randomly selected element, but#       x[i] cannot be swapped with itself (because that wouldn't be a neighbor would it?)# Initialize variables #solutionsChecked = 0          # number of solutions checked.starts = 0                    # number of random starts executedMAX_STARTS = 2                # maximum number of searches (from a random starting point)MAX_K = 3                     # maximum number of neighborhood structures to search for improving solutionsx_best_overall = []           # empty list as a place holder for the best solution yet foundf_best_overall = 0            # best value of the evaluation function found in the overall searchwhile starts < MAX_STARTS:    # while stopping condition not met    starts += 1    x_curr = getRandomPoint(myPRNG)    f_curr = evaluate(x_curr)    x_best = x_curr[:]    f_best = f_curr    k = 1    while k <= MAX_K:  # until all neighborhood structures have been searched, with no improvement        neighbors = neighborhood(x_curr, k)  # generate a list of all neighbors in neighborhood structure k        for s in neighbors:  # for each neighbor in this neighborhood structure around x_best            solutionsChecked += 1            if evaluate(s) > f_best:  # if a better solution is found                x_best = s[:]                f_best = evaluate(s)        if f_best == f_curr:  # if neighborhood structure k around x_curr offered no improvement            printUpdate()            k += 1  # continue searching the k+1 neighborhood structure around the current point.        else:            x_curr = x_best[:]  # move to the best point found in neighborhood k            f_curr = f_best  # update best fitness to the new point            if f_best > f_best_overall:                x_best_overall = x_best[:]                f_best_overall = f_best            printUpdate()            k = 1  # start searching the k=1 neighobrhood structure around the new point.printUpdate()