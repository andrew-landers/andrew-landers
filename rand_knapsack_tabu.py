################################################# QUESTION 5: TABU SEARCH WITH PATH RE-LINKING ################################################## need some python librariesimport copyfrom random import Randomimport numpy as npimport math# to setup a random number generator, we will specify a "seed" valueseed = 12345myPRNG = Random(seed)# to get a random number between 0 and 1, write call this:             myPRNG.random()# to get a random number between lwrBnd and upprBnd, write call this:  myPRNG.uniform(lwrBnd,upprBnd)# to get a random integer between lwrBnd and upprBnd, write call this: myPRNG.randint(lwrBnd,upprBnd)# number of elements in a solutionn = 100# let's create an instance for the knapsack problemvalues = []for i in xrange(0,n):    values.append(myPRNG.randint(10,100))weights = []for i in xrange(0,n):    weights.append(myPRNG.randint(5,15))# define max weight for the knapsackmaxWeight = 4*n# function to evaluate a solution xdef evaluate(x):    a=np.array(x)    b=np.array(values)    c=np.array(weights)    value = np.dot(a,b)          # compute the cost value of the knapsack selection    totalWeight = np.dot(a,c)    # compute the weight value of the knapsack selection    if totalWeight > maxWeight:        value =  -1    return value# function to create a 1-flip neighborhood of solution xdef neighborhood(x):    nbrhood = []         for i in xrange(0,n):        nbrhood.append(x[:])        if nbrhood[i][i] == 1:            nbrhood[i][i] = 0        else:            nbrhood[i][i] = 1    return nbrhood# function to select a solution at randomdef getRandomPoint(prng):    xRand = []    for i in xrange(0,n):        if prng.random() < 0.7:            xRand.append(0)        else:            xRand.append(1)    return xRand# function to print a status update to the consoledef printUpdate():    print "\nTotal number of solutions checked: ", solutionsChecked    print "Total starts: ", starts    print "Value of current position: ", f_curr    print "Current position: ", x_curr    print "Best value found: ", f_best    print "Best solution found: ", x_best############################################### HELPER FUNCTIONS FOR TABU SEARCH PROCEDURE ################################################ function to return a list of evaluation scores for each point in a neighborhooddef getScores(Neighborhood):    scores = []    for i in xrange(0, len(Neighborhood)):        scores.append(evaluate(Neighborhood[i]))    return scores# function to create a tabu list:#   each element of the list contains the number of iterations for which we are not allowed to move to a poisition#   that differs from the current position at that element (aka we can't flip that element for x moves).def makeTabuList(xCurr):    tabu = []    for i in xrange(0, len(x_curr)):        tabu.append(0)    return tabu# returns the best non-tabu neighbor of a solutiondef getNextMove(myCurr, myNeighborhood, myScores, myTabuList):    best = []    summary = [] # list of lists. In each entry: [neighbor_id, eval, is_tabu]    # making a table of attributes related to each neighbor, call this table 'summary'.    for i in xrange(0, len(myNeighborhood)):        my_neighbor = []        my_neighbor.append(i)        my_neighbor.append(myScores[i])        my_neighbor.append(isTabu(myCurr, myNeighborhood[i], myTabuList))        summary.append(my_neighbor)    summary.sort(key=lambda x: (x[1]), reverse=True) # sort by 2nd item (fitness), descending    i = 0  # index to check next in the list of neighbors    while len(best) == 0:  # while a non-tabu neighbor has not been assigned to best        if not summary[i][2]:            best = myNeighborhood[summary[0][i]][:]        # Aspiration criteria: a tabu solution will be moved to if it is better than any other solution yet found        elif evaluate(myNeighborhood[summary[0][i]]) > f_best:            best = myNeighborhood[summary[0][i]][:]        else:            i += 1    return best# Function to update the tabu list after a move has been performeddef updateTabuList(myLast, myCurr, myTabuList, period):    tabu = myTabuList[:]    # create a local copy of the tabu list    for i in xrange(0, len(myTabuList)):        if myLast[i] != myCurr[i]:            myTabuList[i] = period #set a tabu period on changing this element again.        else:            myTabuList[i] = max(0, myTabuList[i] - 1)   # otherwise, reduce the waiting period by 1 (but not below 0).    return tabu# Function to determine whether a candidate solution is currently tabu.def isTabu(myCurr, myNeighbor, myTabuList):    result = False  # tabu will start as false and we will attempt to falsify this statement.    i = 0  # loop counter    # inspect all elements of myNeighbor until either a tabu element is found or the entire solution is verified    while i < len(myNeighbor) and not result:        if myTabuList[i] > 0:  # if altering this element is currently tabu            if myNeighbor[i] != myCurr[i]:  # and the element *is* altered in this solution                result = True  # flag this solution as tabu. this will escape the loop.        i += 1    return result# Function to perform path-relinking between two points and return the best solution along the pathdef relink(my_start, my_stop):    my_curr = my_start[:]  # start with a copy of the starting point    my_best = my_curr[:]   # this will be the best solution along the relinking path.    changeable = []   # for each element: 1 if it can still be flipped moving to the ending solution, 0 otherwise    for i in xrange(0, len(my_curr)):        changeable.append(1) # all elements start out flippable until they have been flipped.    while not is_same(my_curr, my_stop):  # While my_curr differs from my_stop        my_neighborhood = neighborhood(my_curr)  # Generate a list of all 1-flip neighbors vis-a-vis my_curr        neighbor_summary = []        # for each neighbor in the neighborhood.        for i in xrange(0,len(my_neighborhood)):            my_neighbor = []            my_neighbor.append(i)  # neighbor index of neighbor i            my_neighbor.append(num_of_diff(my_neighborhood[i], my_stop))  # number of flips to my_stop from neighbor i            my_neighbor.append(evaluate(my_neighborhood[i]))  # evaluation of the neighbor i            my_neighbor.append(differ_at(my_curr, my_neighborhood[i]))  # element index flipped in neighbor i            neighbor_summary.append(my_neighbor) # add this row to the table        neighbor_summary.sort(key=lambda x: (x[1], -x[2]))  # sort by diff (ascending) then by evals (descending)        # Move to the most similar neighbor. If multiple neighbors are equally similar in terms of number of flips,        # then move to the one that evaluates the highest        choice = 0        while changeable[neighbor_summary[choice][3]] == 0:            choice += 1        changeable[neighbor_summary[choice][3]] = 0  # disallow further changes at this element        my_curr = my_neighborhood[neighbor_summary[choice][0]][:]  # update current position in the re-linking path        if evaluate(my_curr) > evaluate(my_best):  # if this happens to be the best solution yet found:            my_best = my_curr[:]    return my_best# Function to return the index of the element at which two neighbors differdef differ_at(list1, list2):    result = -1    i = 0    while result < 0:        if list2[i] - list1[i] != 0:            result = i        else:            i += 1    return result# Function to return True if two solutions are identical, False otherwise.#   *NOTE: this method assumes that both lists passed as arguments are numerical and of equal lengthdef is_same(list1, list2):    result = True    i = 0    while i < len(list1) and result:        if list1[i] != list2[i]:            result = False        i += 1    return result# Function to return the number of positions at which two elements differdef num_of_diff(list1, list2):    result = 0    for i in xrange(0, len(list1)):        if list2[i] != list1[i]:            result += 1    return result################################################# TABU SEARCH PROCEDURE (with path re-linking) ################################################## Aspiration criteria: A tabu solution will be moved to if it is better than any other solution yet found# Path relinking strategy, performing path re-linking at the end of each restart (the outer loop).TABU_PERIOD = 5       # number of iterations it will be tabu to re-flip the same element.solutionsChecked = 0  # number of solutions checked.starts = 0            # number of startsMAX_STARTS = 25       # maximum number of iterationsmax_moves = 200       # maximum number of moves to execute from a given starting positionx_best = []           # empty list as a place holder for the best solution yet foundf_best = 0            # best value of the evaluation function found in the overall search# Begin the searchwhile starts < MAX_STARTS:    # while stopping condition not met    moves = 0  # number of moves taken from the current starting position    x_first = getRandomPoint(myPRNG)   # select a random solution in the search space    f_first = evaluate(x_first)  # evaluate the first point    x_curr = x_first[:]  # make this solution the current solution    starts += 1  # increment the number of starts    tabuList = makeTabuList(x_curr) # initialize the "tabu list" (no restrictions)    while not moves == max_moves:  # while current search has not been completed        Neighborhood = neighborhood(x_curr)   # create a list of all neighbors in the neighborhood of x_curr        scores = getScores(Neighborhood)  # create a list of evaluation scores for each point in the neighborhood        solutionsChecked += len(Neighborhood)  # increment the number of solutions checked accordingly.        x_last = x_curr[:]        x_curr = getNextMove(x_curr, Neighborhood, scores, tabuList)        f_curr = evaluate(x_curr)        tabuList = updateTabuList(x_last, x_curr, tabuList, TABU_PERIOD)  # update the tabu list        moves += 1    # if this start yielded the best solution so far, save it as the best solution yet.    if f_curr > f_best:        x_best = x_curr[:]        f_best = f_curr    # If there was at least some improvement, perform path relinking between x_first and x_curr    if f_curr > f_first:        x_relink = relink(x_first, x_curr)        solutionsChecked += len(Neighborhood) * num_of_diff(x_first, x_curr)        # If the solution returned from path relinking is the best yet, then update the variables accordingly        if evaluate(x_relink) > f_curr:            x_curr = x_relink[:]            f_curr = evaluate(x_relink)            print "\nPath re-linking found a better solution. Value: ", f_curr            if f_curr > f_best:                x_best = x_curr[:]                f_best = f_curr                print "And it's the best solution yet found! Value: ", f_best    printUpdate()printUpdate()